\documentclass[11pt]{scrartcl}
\usepackage{amsmath,graphicx,url,paralist}
\usepackage{listings,bera}
\usepackage[scaled=0.9]{helvet}
\usepackage{color,calc,url,upquote}
\usepackage{textcomp}
\usepackage[charter]{mathdesign}
\usepackage{microtype}
\parindent0pt
\definecolor{var}{rgb}{0,0.28,0.28}
\definecolor{kw}{rgb}{0,0,0.5}
\definecolor{comment}{rgb}{0,0.5,0}
\definecolor{string}{rgb}{0.6,0,0.5}
\definecolor{errmsg}{rgb}{1,0,0}
\newcommand{\blist}[1]{\mbox{\lstinline!#1!}}
\newcommand{\mlvar}[1]{\lstinline[keywordstyle=\color{var}]!#1!}
\newcommand{\genvar}[1]{\textit{\texttt{#1}}}
\newlength{\tabw}
\lstset{language=Matlab,%
  basicstyle={\ttfamily\small},%
  commentstyle=\color{comment},%
  stringstyle=\color{string},%
  keywordstyle=\color{kw},%
  identifierstyle=\color{var}%
}
\usepackage[pdftex,colorlinks]{hyperref}
\definecolor{darkblue}{cmyk}{1,0,0,0.8}
\definecolor{darkred}{cmyk}{0,1,0,0.7}
\hypersetup{anchorcolor=black,
  citecolor=darkblue, filecolor=darkblue,
  menucolor=darkblue,pagecolor=darkblue,urlcolor=darkblue,linkcolor=darkblue}
\usepackage{cleveref}
\renewcommand{\d}{\mathrm{d}}
\newcommand{\R}{\mathbb{R}}
\providecommand{\e}{\mathrm{e}}
\begin{document}
\title{Generation of right-hand sides and their
  derivatives with Matlab's symbolic toolbox --- \texttt{symcoco}}

\author{Jan Sieber, University of Exeter}
\date{}
\maketitle
\tableofcontents
The routines in \blist{symcoco} provide a wrapper around Matlab's
symbolic toolbox and its code generation functions to
generate user-defined right-hand sides and their derivatives in a vectorized form.

Matlab's symbolic toolbox only needs to be present during the
generation of the right-hand sides. No \textsc{coco} routines are
called during the generation. The generated functions use only
standard Matlab commands such that access to the symbolic toolbox is
not required during \textsc{coco} computations.

The symbolic operations, including the call to \blist{sco_sym2funcs}
is compatible with \texttt{octave}'s \texttt{symbolic} package.
\section{Changes}
\label{sec:changes}

\subsection*{(2023)}
\label{sec:2023}
\begin{itemize}
\item (Bugfix by Alois Steindl) The test in \blist{matlabFunction} for
  the \blist{end} keyword relied on \blist{strsplit}, which behaves
  differently for windows and linux/matlab online. The test for the
  \blist{end} keyword now uses \blist{strncmp(}\ldots\blist{,'end',3)} instead of
  \blist{strcmp(}\ldots\blist{,'end')}, ignoring trailing symbols.
\item (Bugfix) The symbolic toolbox's \blist{matlabFunction} may
  create local subfunctions on its own , always using the same
  name. This prevents utting all generated functions into one file. A
  work-aound is the new option \blist{'multifile'} and
  \blist{'folder'}, where each generated function is put into its own
  file, if requested into the requested folder (\blist{'./private} is
  a convenient choice).
\item (Bugfix) The symbolic toolbox's \blist{matlabFunction} may treat
  symbolic expressions that overlap builtins incorrectly (e.g.,
  \blist{beta}). A new default is to rename all variables to
  \blist{in1,in2,...}. Set prefix with option \blist{'inname'} and
  disable this renaming by setting option \blist{'rename'} to
  \blist{false} (default \blist{true}).
\item (Bugfix) The function \blist{sco_sym2funcs} tests if \blist{matlabFunction} generates
  functions with the \blist{end} keyword (this is not the case for
  versions before 2021). This avoids syntax errors in the function file generated by \blist{sco_sym2funcs}.
\item Function \blist{sco_gen} can now output full derivatives up to
  arbitrary order. The maximal order is set by the optional
  \blist{maxorder} argument in \blist{sco_sym2funcs}. These can be
  mixed with directional derivatives.
\end{itemize}
\section{Typical usage}
\label{sec:minimal}

\subsection{Detailed demo based on EP toolbox demo \texttt{bistable}}
\label{sec:bistable}
See folder \texttt{examples\_doc/bistable} for
\begin{compactitem}
\item script \texttt{gen\_sym\_bistable.m} and its html output
  \url{bistable/html/gen_sym_bistable.html}: a script demonstrating
  how one may generate right-hand sides and their partial derivatives
  using the symbolic toolbox and wrapper \texttt{symcoco},
\item script \texttt{demo.m} and its html output
  \url{bistable/html/demo.html}: a script demonstrating how one may
  call the functions generated with \texttt{symcoco}, and use them for
  \textsc{coco} computations.
\end{compactitem}
The example \texttt{bistable} is copied from the \texttt{po}-toolbox
demo of same name. The first part of the demo demonstrates the user
interface for \blist{symcoco} in detail, before following the original
\texttt{ep}-toolbox demo, using the symbolic derivatives.

\subsection{Modification of demos \texttt{sphere\_optim} and \texttt{int\_optim}}
\label{sec:optim}
Tasks involving optimization need second partial derivatives of all
constraints. The demos \texttt{sphere\_optim} from CORE-Tutorial and
\texttt{int\_optim} from the PO-Tutorial have been modified to
demonstrate how derivatives for these problems can be constructed
using \texttt{symcoco}.

\paragraph{\texttt{sphere\_optim}} The outputs
\url{sphere_optim/html/demo.html} and
\url{sphere_optim/html/gen_sym_sphere.html} demonstrate construction
using \blist{sco_sym2funcs} and usage using \blist{sco_gen} of
constraints and objective functional. This demo shows how one can put
the simple functions generated by \blist{sco_gen} into the
\textsc{coco} core format
\begin{lstlisting}
function [data,y]=func(prob,data,u)
\end{lstlisting}
by using
\begin{lstlisting}
fcn = @(f) @(p,d,u) deal(d, f(u));
obj=sco_gen(@sym_sphere_obj);
funcs2 = { fcn(obj('')),fcn(obj('u')),fcn(obj({'u','u'}))};
\end{lstlisting}

\paragraph{\texttt{int\_optim}} The outputs
\url{int_optim/html/demo.html} and
\url{int_optim/html/gen_sym_int_optim.html} demonstrate construction
using \blist{sco_sym2funcs} and usage using \blist{sco_gen} of
constraints and objective functional of a PO-toolbox demo for
successive continuation with integral objective functional and ODE
constraints.



\section{Call arguments}
\label{sec:args}
Construction happens in two steps. Only the first step requires the symbolic toolbox  (or, alternatively, the \texttt{symbolic} package in \texttt{octave}, based on the \texttt{python} package \texttt{sympy}. Each step is a function call:
\begin{compactenum}
\item \blist{sco_sym2funcs} during generation of the right-hand side and its derivatives using the symbolic toolbox;
\item \blist{sco_gen} for creating wrappers around the function
  created by \blist{sco_sym2funcs} that can be used for \textsc{coco} computations.
\end{compactenum}

Function input/output formats:
\begin{lstlisting}[frame=none]
  function [fout,funcstr,derivatives]=sco_sym2funcs(f,args,names,varargin)
  function fout=sco_gen(fun,name)
\end{lstlisting}
where \blist{varargin} are optional pairs of the form
\blist{'name',value} with defaults. Both calls in combination convert symbolic expression
\blist{f} into a matlab function of the form
\begin{lstlisting}[frame=none,identifierstyle={\itshape}]
  function y=sys(action,argseq)
\end{lstlisting}
where \genvar{y} is a $n_y\times1$ vector, and \genvar{argseq} is a
sequence of $n_a$ arguments \genvar{argseq}$_i$ of shape $n_i\times1$,
such that \genvar{sys} depends on overall $n_u=\sum_{i=1}^{n_a}n_i$
scalar variables. Only \blist{sco_sym2funcs} depends on the symbolic
toolbox. It is a wrapper around \blist{matlabFunction} producing a
function file (by default \texttt{sys.m}), which contains all
intermediate information for the wrapper \blist{sco_gen} to return
\genvar{sys} and its derivatives.
\subsection{Example of \blist{sco_symfuncs} call} Demo
\texttt{bistable} creates a function
\begin{align*}
  \R\times\R^2\times\R^3\ni(t,x,p)\mapsto f(t,x,p)\in\R^2
\end{align*}
and its derivatives up to order $3$. This is the underlying right-hand
side $f$ of a differential equation,
\begin{align*}
  \dot x=&v,\\\dot v=&-\gamma v-x-x^3+a\cos(2\pi t/T),
\end{align*}
where we collect $(x;v)\in\R^2$ into the state vector (also called $x$) and
$(T;a;\gamma)$ into the parameter vector $p\in\R^2$:
\begin{align*}
  f\left(t,
    \begin{bmatrix}
      x\\v
    \end{bmatrix},
    \begin{bmatrix}
      T\\a\\\gamma
    \end{bmatrix}\right)=
    \begin{bmatrix}
      v\\
      -\gamma v-x-x^3+a\cos(2\pi t/T)
    \end{bmatrix}.
\end{align*}
\begin{lstlisting}[frame=lines,numbers=left]
syms t x v gam a T 
f=[v; -gam*v-x-x^3+a*cos(2*pi*t/T)]; 
F=sco_sym2funcs(f,...               % symbolic expression for f
    {t,[x;v],[T;a;gam]},...       % which symbols are in which inputs of f
    {'t','x','p'},...             % names for inputs of f
    'vector',[0,1,1],...          % are inputs scalar or vectors
    'filename','sym_bistable',... % filename for result
    'maxorder',3);                % derivatives are computed up to this order
\end{lstlisting}
The resulting $f$ is stored in \texttt{sym\_bistable.m} and function
handles accessing it are generated with \blist{sco_gen}. See the
calling examples in \cref{sec:sco_gen:output} for the effect of the
optional argument \blist{'vector'}.
\subsection{Examples of \blist{sco_gen} usage} See demo \texttt{test}.
Use symbolic toolbox to create a shortcut for generating derivatives:
\begin{lstlisting}
syms t x v gam a T 
F=sco_sym2funcs([v; -gam*v-x-x^3+a*cos(2*pi*t/T)], {t,[x;v],[T;a;gam]},...
   {'t','x','p'}, 'vector',[0,1,1], 'filename','bistable', 'maxorder',3);
\end{lstlisting}
Output \blist{F} can alternatively be generated after call to \blist{sco_sym2funcs} by
\begin{lstlisting}
F=sco_gen(@bistable);   % same as above F
\end{lstlisting}
Suppose the arrays $t\in\R^{1\times N}$, $x\in\R^{n_x\times N}$ and
$p\in\R^{n_p\times1}$ have been created (with $n_x=2$, $n_p=3$). The
right-hand side and first derivatives are generated and called as
follows:
\begin{lstlisting}
     f=F('');           fx=F('x');
   fxp=F({'x','p'});   fpx=F({'p','x'});
  fxvp=F({'x*v','p'}); ftx=F({'t','x'});
   df3=F(3);           df3c=F({3})
  dfxpdir=@(t,x,p,dt,dx,dp)df3c(t,x,p,{0,0,dt},{'I',0,dx},{0,'I',dp})
\end{lstlisting}
\begin{align*}
  \mbox{\blist{f(t,x,p)}:}&&f(t,x,p)&\in\R^{n_y\times N}\\
  \mbox{\blist{fxp(t,x,p)}:}&&\partial^2_{xp}\,f(t,x,p)&\in\R^{n_y\times n_x\times n_p\times N}\\
  \mbox{\blist{fpx(t,x,p)}:}&&\partial^2_{px}\,f(t,x,p)&\in\R^{n_y\times n_p\times n_x\times N}
  &&\mbox{(note effect of ordering in tensor)}\\
  \mbox{\blist{fxvp(t,x,p,v)}:}&&\partial^2_{xp}\,f(t,x,p)v&\in\R^{n_y\times n_p\times N}\\
  \mbox{\blist{ftx(t,x,p)}:}&&\partial^2_{tx}\,f(t,x,p)&\in\R^{n_y\times n_x\times N}&&\mbox{(as \blist{isv}$_1$ is \blist{false}, \textbf{not} in $\R^{n_y\times 1\times n_x\times N}$)}.
\end{align*}
A mix of directional derivatives and full derivatives:
\begin{multline*}
  %dfxpdir=@(t,x,p,dt,dx,dp)feval(F(3),t,x,p,{0,0,dt},{'I',0,dx},{0,'I',dp})
  \mbox{\blist{dfxpdir(t,x,p,dt,dx,dp)}:}\\
  \partial^2_{xp}\left[\partial_{t}\,f(t,x,p)\delta_t+\partial_{x}\,f(t,x,p)\delta_x+\partial_{p}\,f(t,x,p)\delta_p\right]\in\R^{n_y\times n_x\times n_p\times N}.
\end{multline*}
Total derivatives ($n_u=1+n_x+n_p$, $u=(t,x,p)$, $\delta_i=(\delta_{t,i},\delta_{x,i},\delta_{p,i}$):
\begin{align*}
  &\mbox{\blist{df3(t,x,p)}:}&&\partial^3f(u)&&\in\R^{n_y\times (n_u)^3\times N}\\
  &\mbox{\blist{df3(t,x,p,\{dt1\},\{dx1\},\{dp1\})}:}&&\partial^3f(u)\delta_1&&\in\R^{n_y\times (n_u)^2\times N}\\
  &\mbox{\blist{df3(t,x,p,\{dt1,dt2\},\{dx1,dx2\},\{dp1,dp2\})}:}&&\partial^3f(u)\delta_1\delta_2&&\in\R^{n_y\times n_u\times N}\\
  &\mbox{\blist{df3(t,x,p,\{dt1,dt2,dt3\},\{dx1,dx2,dx3\},\{dp1,dp2,dp3\})}:}&&\partial^3f(u)\delta_1\delta_2\delta_3&&\in\R^{n_y\times N}
\end{align*}

\subsection{Inputs of \blist{sco_sym2funcs}}
\begin{compactitem}
\item \blist{f}: right-hand side, $n_y\times1$ array of matlab
  symbolic expressions. This variable contains the mathematical
  expression to be converted into the matlab function \genvar{sys}
  and differentiated with respect to its arguments. The expression
  \blist{f} depends on $n_u$ scalar symbolic variables (a scalar
  symbolic variable \blist{x} is a Matlab variable for which
  \blist{diff(f,x)} is a valid expression).
\item \blist{args}: partition of variables in symbolic expression
  \blist{f} into arguments \genvar{argseq} of function \genvar{sys},
  $1\times n_a$ cell array. Each element \blist{args\{i\}} is a
  $n_i\times1$ array of scalar symbolic variables, corresponding to
  \genvar{argseq}$_i$, such that \blist{cat(1,args\{:\})} is an array
  of length $n_u$ containing all scalar variables that \blist{f}
  depends on.
\item \blist{names}: names of arguments of output function
  \genvar{sys}, $1\times n_a$ cell array of character strings. These
  names can be used in second input of \blist{sco_gen} to obtain
  partial derivatives with respect to arguments of \genvar{sys}.
\item (optional) \blist{'filename'} (character string, default
  \blist{'sys'}): file name (without ending \blist{'.m'}), in which
  the resulting function is stored as a side effect of
  \blist{sco_sym2funcs}.
\item (optional) \blist{'vector'} (logical $1\times n_a$ vector
  \mlvar{isv}, default \blist{true(1,length(args))}): flag whether
  \blist{args\{i\}} is treated as a scalar or vector. Note that if
  \blist{isv(i)} is false then $n_i$ must be equal to $1$, but
  \blist{isv(i)} may be true, even if $n_i=1$. This affects the
  vectorized output of partial derivatives with respect to
  \genvar{argseq}$_i$.
\item (optional) \blist{'maxorder'} (positive integer, default $2$):
  maximal order up to which derivatives will be computed. Currently,
  the wrapper \blist{sco_gen} provides only directional derivatives
  for derivatives of order greater than $2$.
\item (optional) \blist{'write'} (logical, default \blist{true}):
  instruction whether to write the resulting function to file.
\item (optional) \blist{'multifile'} (logical, default
  \blist{false}). When the code generation is more complex,
  \blist{matlabFunction} may generate local subfunctions with
  hard-to-control names. This prevents appending the generated functions from being collected in a single file. With this option , the generated files will be of the form \textit{\textsf{filename}}\texttt{\_rhs\_}$k$\texttt{.m}, where \textit{\textsf{filename}} is the optional input for \blist{'filename'} and $k$ is the order of the derivative.
\item (optional) \blist{'folder'} (character string, default
  \blist{pwd()}) the generated files may be placed in a different
  folder, provided here. A convenient choice may be the local
  subfolder \blist{fullfile(pwd(),'private')}, because then the
  generated files will be found by all script or function files in the
  current folder (however, beware that they are not found on the
  command line).
\item (optional) \blist{'output'} (one of the strings from
  \blist{'fout'}, \blist{'funcstr'} and \blist{'derivatives'}, or a
  cell with several of these strings, default\ \blist{\{'fout','funcstr','derivatives'\}}) controls the order and
  appearance of outputs.
\end{compactitem}


\subsection{Outputs of \blist{sco_sym2funcs}}
The main result is usually the side effect producing a file storing
the generated functions. Control order and appearance of outputs using
optional input \blist{'output'}
\begin{compactitem}
\item \blist{fout} if option \blist{'write'} is set to true,
  \blist{sco_sym2funcs} calls \blist{fout=sco_gen(str2func(filename))}
  at the end of its code generation to create the function generator
  \blist{fout} (see outputs of \blist{sco_gen} in
  \cref{sec:sco_gen:output} for how to use \blist{fout}). Note that
  this output cannot be generated if function files are stored in a
  \texttt{private} folder.
\item \blist{funcstr} character array (including newlines for line
  breaks that contains the text that was (or would have been) written
  to the output file.
\item \blist{derivatives} array of structures of length
  \blist{maxorder-1}. The structure \blist{derivatives(i+1)} contains
  the fields \mlvar{df} of shape $n_y\times1$, and \mlvar{x} and
  \mlvar{dx} (both of shape $n_u\times1$). The symbolic expression
  \blist{derivatives(i).df} contains the directional derivative of
  order $i-1$ in \blist{x}, in direction \blist{dx}. The field
  \blist{x} will equal \blist{cat(1,args{:})}, the field \blist{dx}
  contains the names of the deviations (by default these are the names
  in \blist{x}, extended by \blist{'_dev'}).
\end{compactitem}

\subsection{Inputs of \blist{sco_gen}}
\begin{compactitem}
\item \blist{fun}: character string, name of file or function handle
  produced by \blist{sco_symfuncs}.
\item \blist{name} has several use cases. It controls the format and nature of the output \blist{fout}. Name may be
  \begin{compactenum}[(i)]
  \item absent, or
  \item the empty string (\blist{''}),
  \item\label{ch1} a character string from the list in input \genvar{names} of
    \blist{sco_sym2funcs},
  \item\label{ch2} $1\times m$ cell of character strings from the list in input \genvar{names} of
    \blist{sco_sym2funcs} ($1\leq m\leq$\blist{'maxorder'} argument from \blist{sco_sym2funcs}),
  \item each of the character strings in points \ref{ch1} or \ref{ch2}
    may be followed by a \blist{'*'} and an arbitrary (ignored) letter
    sequence, or
  \item integer \blist{k} less or equal than optional input \blist{'maxorder'}
    of \blist{sco_sym2funcs}.
  \end{compactenum}
\item \blist{debug} (default \blist{false}): logical flag. If set to
  \blist{true}, all assertions concerning argument format inside the
  generated functions are tested (slowing the functions down).
\end{compactitem}
See \Cref{sec:sco_gen:output} for details and examples.
\subsection{Output of \blist{sco_gen}}\label{sec:sco_gen:output}
Output \blist{fout} is a function handle that can be called in a
vectorized form, returning the function \genvar{sys} or its partial
derivatives with respect to the arguments in \genvar{argseq}, or its
directional derivatives. The format of \blist{fout} depends on the second input, \blist{name} to \blist{sco_gen}.
\begin{compactenum}[(i)]
\item (\blist{name} absent)
  \begin{tabbing}
    \blist{F=sco_gen(fun);}\qquad\qquad\quad\= returns 
    \blist{F=@(name)sco_gen(fun,name,false);}\\
    \blist{F=sco_gen(fun,'_debug');}\> returns 
    \blist{F=@(name)sco_gen(fun,name,true);}
  \end{tabbing}
  to provide shortcuts. The final logical flag switches on assertion checking.
\item (\blist{name} is \blist{''}) \blist{fout} is handle to \genvar{func}, expecting
  $n_a$ arguments, where the $i$th argument has shape $n_i\times N$,
  for some $N\geq 1$. After \blist{y=fout(...)}, $y$ has shape
  $n_y\times N$.
\item\label{ch1:out} (\blist{name} is character string \genvar{argname} or $1\times1$ cell with a
  character string \genvar{argname} from the list in input
  \genvar{names} of \blist{sco_sym2funcs}) \blist{fout} is function
  handle, expecting $n_a$ arguments, where the $i$th argument has
  shape $n_i\times N$, for some $N\geq 1$. If \genvar{argname}
  equals \genvar{names}$_k$, then, after \blist{J=fout(...)}, $J$ is
  the partial derivative of \genvar{sys} with respect to
  \genvar{argseq}$_k$ which has shape $n_y\times n_k\times N$.
\item\label{ch2:out} (\blist{name} is $1\times m$ cell
  \blist{\{}\genvar{argname}$_1$\blist{,}\ldots\genvar{argname}$_m$\blist{\}}
  with character strings from the list in input \genvar{names} of
  \blist{sco_sym2funcs}) \blist{fout} is function handle, expecting
  $n_a$ arguments, where the $i$th argument has shape $n_i\times N$,
  for some $N\geq 1$. If \genvar{argname}$_j$ equals
  \genvar{names}$_{k_j}$ and \blist{isv}$_{k_j}$ is \blist{true},
  then, after \blist{J=fout(...)}, $J$ is the $m$-order partial
  derivative of \genvar{sys} with respect to
  \genvar{argseq}$_{k_1}$,\ldots,\genvar{argseq}$_{k_m}$, which has
  shape $n_y\times n_{k_1}\times\ldots\times n_{k_m}\times N$.
\item Arguments in points (\ref{ch1:out}) and (\ref{ch2:out}) may
  contain the symbol \blist{'*'} to create directional derivatives in
  this argument. Then \blist{fout} requires one additional argument
  and the output reduces by the dimension of this input.
\item (name is integer \blist{k} less than or equal to the optional
  input \blist{'maxorder'} of \blist{sco_sym2funcs}) \blist{fout} is
  function handle to the total derivative of order $k$, applied to up
  to $k$ deviations, expecting $n_a$ or $2n_a$ inputs. Input $i$ for
  $i\leq n_a$ is double array of shape $n_i\times N$, corresponding to
  the base point where the total or directional derivative of
  \genvar{sys} is taken. Input $n_a+i$ for $i\in\{1,\ldots,n_a\}$ is a
  cell array of length $\ell\leq k$, where each entry has shape
  $n_i\times N$. These are the deviations for the $k$th derivative
  applied to the $i$th argument of \genvar{sys}.
\item (name is cell containing single integer \blist{k} less than or
  equal to the optional input \blist{'maxorder'} of
  \blist{sco_sym2funcs}) Same as integer argument, but all deviation
  arguments must have $k$ elements. For this call optionally, the
  $\ell$th entry of one cell array argument may be the capital letter
  \blist{'I'}. Then all other $\ell$th entries of all cells have to be
  \blist{0}. For the entry with \blist{'I'}  the derivative will be full.
\end{compactenum}


\section{Internal procedure for differentiation and code generation}
\label{sec:internal}

\subsection{Procedure for symbolic differentiation and code generation}
\label{sec:diff}
In short, the only functionality of the Matlab symbolic toolbox that
is needed are \blist{subs}, \mlvar{diff} and the code generation tool
\blist{matlabFunction}. Step-by-step procedure is described below.
\begin{compactenum}
\item Inside \blist{sco_sym2funcs} all variables, which the symbolic
expression $f$ (\blist{f}) depends on are collected as a single argument
$u=$\blist{vertcat(args\{:\});}. 
\item New symbols $u_\mathrm{dev}$ (\blist{udev}) are introduced, with names (by
  default) \blist{[x,'_dev']}, where \blist{x} are the names of the
  symbols in $u$. The name of the extension can be overwritten by the
  optional input \blist{'dev_append'} to \blist{sco_sym2funcs}.
\item A new symbol $h$ (\blist{h}) with default name
  \blist{'h_devsmall'} is introduced. The name of $h$ can be
  overwritten by the optional input \blist{'deviation_name'} to
  \blist{sco_sym2funcs}.
\item Derivatives up to order $k_{\max}$ (given by optional input
  \blist{'maxorder'}, default $k_{\max}=2$) of the form
  \begin{equation}\label{dir1deriv}
    D_kf(u)[u_\mathrm{dev}]^k:=\left.\frac{\partial^k}{\partial h^k}f(u+hu_\mathrm{dev})\right\vert_{h=0}
  \end{equation}
  are computed via symbolic toolbox commands
  \begin{lstlisting}[frame=lines]
    fdev=subs(f,u,u+h*udev);
    hrep=repmat({h},1,k);
    df{k+1}=subs(diff(fdev,hrep{:}),h,0);
  \end{lstlisting}
  where the new symbolic expressions \blist{df\{k\}} depend on the
  symbolic variables \blist{[u(:);udev(:)]}, and \blist{df\{1\}} is the original expression \blist{f}.
\item Each expression \blist{df\{k\}} is output (for Matlab) into a temporary file
  \begin{lstlisting}
    folder=tempname;
    fname=sprintf('%s_%d',[filename,'_rhs'],k-1);
    filename=fullfile(folder,[fname,'.m']);
  \end{lstlisting}
  where \blist{filename} is the optional input \blist{'filename'} of
  \blist{sco_sym2funcs} (default \blist{'sys'}), using symbolic
  toolbox function \blist{matlabFunction}.

  For octave, the expressions are passed on to
  \blist{sympy.utilities.codegen.codegen} in the python module
  \blist{sympy}.
\item The temporary files are read back into a character string, to
  which a header, providing control for calling the resulting
  intermediate function file, is added. The resulting character string
  is then written to the optional input \blist{'filename'} of
  \blist{sco_sym2funcs} (default \blist{'sys'}), with extension
  \blist{'.m'}. By default, the temporary files are deleted (overwrite
  with optional argument \blist{'keeptemp'}).
\end{compactenum}

\paragraph{Directional derivatives in arbitrary directions}
The expression \eqref{dir1deriv} constructs $k$th order derivatives
only in a single direction $u_\mathrm{dev}$. Directional $k$th
derivatives with an arbitrary set of $k$ directions,
$\partial^kf(u)[v_1,\ldots,v_k]$ are then constructed using the
telescope formula
\begin{displaymath}
  \partial^kf(u)[v_1,\ldots,v_k]=
  \frac{1}{2^{k-1}(k!)}\sum_{p\in \{-1,1\}^k}\left[\prod_{i=1}^kp_i\right]\partial^kf(u)\left[\sum_{i=1}^k p_iv_i\right]^k\mbox{.}
\end{displaymath}
The index set $\{-1,1\}^k$ refers to all sequences $p$ of $-1$'s and
$1$'s of length $k$. The special case for $k=1$ is trivial
($\partial^1f(u)v_1$). For the case for $k=2$ the formula equals
\begin{displaymath}
  \frac{1}{4}\left(\partial^2f(u)[v_1+v_2]^2-\partial^2f(u)[v_1-v_2]^2\right)\mbox{.}
\end{displaymath}
\subsection{Control information and calling format of generated
  intermediate function}
\label{sec:intermediate}
The call to \blist{sco_sym2funcs} creates a matlab function with default name \blist{sys} of the format
\begin{lstlisting}
  function varargout=sys(action,varargin)
\end{lstlisting}
The input \blist{action} is a character string that controls the type of output:
\begin{compactitem}
\item \blist{'nargs'}: number of arguments, $n_a$,
\item \blist{'nout'}: row dimension of output, $n_y$,
\item \blist{'argrange'}: structure with field names equal to
  \genvar{names}$_i$, and values pointing into the range or rows of
  input \blist{u=cat(1,args\{:\})}. Thus,
  \blist{argrange.(}\genvar{names}$_i$\blist{)} is the range of
  indices from $1+\sum_{j=1}^{i-1}n_j$ to $\sum_{j=1}^in_j$.
\item \blist{'argsize'}: structure with field names equal to
  \genvar{names}$_i$, and values $n_i$.
\item \blist{'vector'}: $1\times n_a$ logical array, equal to optional
  input \blist{'vector'}.
\item \blist{'maxorder'}: integer, maximal order of derivatives
  computed, equal to input \blist{'maxorder'}.
\item \blist{'extension'}: extension of name for the functions for the
  directional derivatives (the name is equal to
  \blist{[}\genvar{filename}\blist{,'_',}\genvar{extension}\blist{,'_',num2str(}$k$\blist{)]}
  for the $k$the derivative. This string is needed for calling the function (see next item).
\item If \blist{action} equals the string returned by
  \blist{sys('extension')}, then the $k$th derivative in $u$
  in direction $u_\mathrm{dev}$ is returned. The integer $k$ is
  \blist{varargin\{1\}} ($k=0$ is possible and returns the
  undifferentiated function). The row $i$ of $u$ is
  \blist{varargin\{1+i\}}, row $i$ of $u_\mathrm{dev}$ is
  \blist{varargin\{1+}$n_u$\blist{+i\}}.
\end{compactitem}







\end{document}
